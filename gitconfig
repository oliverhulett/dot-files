[alias]
	lg = "!f() { if [ $# -eq 0 ]; then set -- 10; fi; count=\"--max-count=$1\"; if [ \"$1\" == \"-a\" -o \"$1\" == \"--all\" ]; then count=; fi; git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cd)%C(bold blue)<%an>%Creset' --abbrev-commit $count; }; f"
	alias = config --get-regexp alias
	which = "!f() { for i in \"$@\"; do echo -n \"$i is: \"; git config alias.$i; done; }; f"

	ticket = "!f() { git branch --no-color | sed -nre 's/^\\* //p' | cut -d'_' -f1; }; f"
	this = "!f() { git branch --no-color | sed -nre 's/^\\* //p'; }; f"

	upstream = "!f() { git push --set-upstream origin $(git this); }; f"
	branches = branch -avv
	remotes = remote -v
	refs = for-each-ref refs/remotes/origin
	who = "!f() { git for-each-ref --sort=-authorname --format='%(authorname)#%(committerdate)#%(refname)#%(subject)' refs/remotes/origin/ \"$@\" | column -ts'#' -o'    '; }; f"
	when = "!f() { git for-each-ref --sort=-committerdate --format='%(authorname)#%(committerdate)#%(refname)#%(subject)' refs/remotes/origin/ \"$@\" | column -ts'#' -o'    '; }; f"
	tags = "!f() { if [ $# -eq 0 ]; then set -- 5; fi; count=\"--lines=$1\"; if [ \"$1\" == \"-a\" -o \"$1\" == \"--all\" ]; then count=\"--lines=-0\"; fi; git for-each-ref --format='%(taggerdate:raw)%(committerdate:raw)#%(taggerdate)%(committerdate)#%(refname:short)#%(authorname)%(*authorname)#%(subject)' refs/tags | sort -rn | cut -d'#' -f2- | head $count | column -ts'#' -o'    '; }; f"

	rmtag = "!f() { for t in \"$@\"; do git tag -d $t && git push origin :refs/tags/$t; done; }; f"
	pushtags = push --tags

	cp = "!f() { cp -nv \"$@\"; declare -a toadd; if [ -d \"${@:$#}\" ]; then for arg in \"${@:1:$# - 1}\"; do if [ \"${arg:0:1}\" != \"-\" ]; then toadd[${#toadd[@]}]=\"${@:$#}/$(basename $arg)\"; fi; done; else toadd=( \"${@:$#}\" ); fi; git add -v --ignore-errors \"${toadd[@]}\"; }; cd \"$GIT_PREFIX\" && f"
	new = "!f() { ~/.git_wrappers/new.sh \"$@\"; }; cd \"$GIT_PREFIX\" && f"
	update = "!f() { ~/.git_wrappers/update.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX
	ignore = "!f() { for i in \"$@\"; do echo \"$i\" >>.gitignore; done; echo \"$(sort -u .gitignore)\" >.gitignore; sed -re '/^$/d' -i .gitignore; git add .gitignore; }; cd \"$GIT_PREFIX\" && f"
	pin = "!f() { ~/.git_wrappers/pin_externals.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX
	unpin = "!f() { ~/.git_wrappers/unpin_externals.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX
	upgrade = "!f() { ~/.git_wrappers/update_externals.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX
	externals2tags = "!f() { ~/.git_wrappers/tag_externals.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX

	unstage = reset HEAD
	undo-commit = reset HEAD^
	discard = reset --hard HEAD
	cleanignored  = "!f() { ~/.git_wrappers/cleanignored.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX
	cleanall = "!f() { ~/.git_wrappers/cleanall.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX

	pullb = "!f() { git pull --prune --recurse-submodules "$@"; git cleanbranches; }; f" ## Want to execute from top level, not GIT_PREFIX
	cleanbranches = "!f() { shopt -s nullglob; test -d .git && for h in $(cd .git/refs/heads && find ./ -type f); do set -- .git/refs/remotes/*/\"${h#./}\"; if [ $# -eq 0 -a \"${h#./}\" != \"master\" ]; then git branch -d \"${h#./}\"; fi; done; }; f" ## Want to execute from top level, not GIT_PREFIX
	mkbranch = "!f() { ~/.git_wrappers/mkbranch.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX
	mvbranch = "!f() { : git branch ; git branch -m \"$1\" \"$2\" && git push origin :\"$1\" && git push --set-upstream origin \"$2\"; }; f"
	rmbranch = "!f() { : git branch ; dashd=\"-d\"; if [ \"$1\" == \"-D\" ]; then dashd=\"-D\"; shift; fi; for b in \"$@\"; do git branch $dashd \"$b\"; git push origin --delete \"$b\"; done; git pull --prune; }; f"

	mergeflict = "!f() { : git branch ; git push; git pull --all && git fetch origin $1 && git merge FETCH_HEAD; }; f"
	gresolve = "!f() { : git mergetool ; git mergetool --tool=kdiff3 -y \"$@\" && echo \"Removing kdiff3 original files.\" && find ./ -name '*.orig' -delete -print; } && f" ## Want to execute from top level, not GIT_PREFIX
	resolved = "!f() { : git add ; if [ $# -eq 0 ]; then set -- $(git diff --name-only --diff-filter=U); fi; git add \"$@\"; }; cd \"$GIT_PREFIX\" && f"

	resolve = "!f() { : git add ; if [ $# -eq 0 ]; then set -- $(git diff --name-only --diff-filter=U); fi; ~/.git_wrappers/resolve.sh \"$@\"; read -n1 -p\"Resolved? [y/N]: \"; echo; if [ \"$(echo $REPLY | tr '[A-Z]' '[a-z]')\" == \"y\" ]; then git add \"$@\"; fi; }; cd \"$GIT_PREFIX\" && f"
	resolve-mine = "!f() { : git add ; if [ $# -eq 0 ]; then set -- $(git diff --name-only --diff-filter=U); fi; git checkout --ours \"$@\" && git add \"$@\"; }; cd \"$GIT_PREFIX\" && f"
	resolve-ours = !git resolve-mine
	resolve-theirs = "!f() { : git add ; if [ $# -eq 0 ]; then set -- $(git diff --name-only --diff-filter=U); fi; git checkout --theirs \"$@\" && git add \"$@\"; }; cd \"$GIT_PREFIX\" && f"
[add]
	ignoreErrors = true
[color]
	branch = auto
	diff = auto
	grep = auto
	interactive = auto
	pager = false
	status = auto
	ui = true
[column]
	ui = never
[grep]
	lineNumber = true
	patternType = extended
[push]
	default = upstream
[merge]
	conflictstyle = diff3
[core]
	pager = less -RFiMx4 -+S
	editor = ~/.git_wrappers/commit.sh
	excludesfile = /home/olihul/.gitignore
	safecrlf = true
	abbrev = 11
[log]
	date = local
[branch]
	autosetuprebase = always
[pull]
	rebase = true
[help]
	autocorrect = 5
[remote "origin"]
	fetch = refs/heads/*:refs/remotes/origin/*
	fetch = refs/tags/*:refs/tags/*
[diff "nodiff"]
	command = /usr/bin/true
[user]
	name = Oliver Hulett
	email = oliver.hulett@optiver.com.au
