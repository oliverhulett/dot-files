[user]
	name = Oliver Hulett
	email = Oliver.Hulett@Optiver.com.au
[alias]
	lgall = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cd)%C(bold blue)<%an>%Creset' --abbrev-commit 
	lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cd)%C(bold blue)<%an>%Creset' --abbrev-commit --max-count=10
	alias = config --get-regexp alias
	which = "!f() { for i in \"$@\"; do echo -n \"$i is: \"; git config alias.$i; done; }; f"

	ticket = "!f() { git branch --no-color | sed -nre 's/^\\* //p' | cut -d'_' -f1; }; f"
	this = "!f() { git branch --no-color | sed -nre 's/^\\* //p'; }; f"

	upstream = "!f() { git push --set-upstream origin $(git this); }; f"
	branches = branch -avv
	remotes = remote -v
	refs = for-each-ref refs/remotes/origin
	who = for-each-ref --sort=-authorname --format='%(authorname)\t%(committerdate)\t%(refname)' refs/remotes/origin/

	tags = tag
	rmtag = tag -d
	pushtags = push --tags

	cp = "!f() { cp -v \"$1\" \"$2\"; git add \"$2\"; }; cd \"$GIT_PREFIX\" && f"
	new = "!f() { ~/.git_wrappers/new.sh \"$@\"; }; cd \"$GIT_PREFIX\" && f"
	update = "!f() { ~/.git_wrappers/update.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX

	unstage = reset HEAD
	undo-commit = reset HEAD^
	discard = reset --hard HEAD
	cleanignored  = "!f() { ~/.git_wrappers/cleanignored.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX
	cleanall = "!f() { ~/.git_wrappers/cleanall.sh \"$@\"; }; f" ## Want to execute from top level, not GIT_PREFIX

	pullb = "!f() { git pull --prune "$@"; git cleanbranches; }; f" ## Want to execute from top level, not GIT_PREFIX
	cleanbranches = "!f() { shopt -s nullglob; for h in .git/refs/heads/*; do set -- .git/refs/remotes/*/\"$(basename \"$h\")\"; if [ $# -eq 0 -a \"$(basename \"$h\")\" != \"master\" ]; then git branch -d \"$(basename \"$h\")\"; fi; done; }; f" ## Want to execute from top level, not GIT_PREFIX
	mkbranch = "!f() { ~/.git_wrappers/mkbranch.sh \"$*\"; }; f" ## Want to execute from top level, not GIT_PREFIX
	mvbranch = "!f() { : git branch ; git branch -m \"$1\" \"$2\" && git push origin :\"$1\" && git push --set-upstream origin \"$2\"; }; f"
	rmbranch = "!f() { : git branch ; dashd=\"-d\"; if [ \"$1\" == \"-D\" ]; then dashd=\"-D\"; shift; fi; git branch $dashd \"$1\"; git push origin --delete \"$1\"; git pull --prune; }; f"

	mergeflict = "!f() { : git branch ; git push && git pull --all && git fetch origin $1 && git merge FETCH_HEAD; }; f"
	gresolve = "!f() { : git mergetool ; git mergetool --tool=kdiff3 -y \"$@\" && echo \"Removing kdiff3 original files.\" && find ./ -name '*.orig' -delete -print; } && f" ## Want to execute from top level, not GIT_PREFIX
	resolved = "!f() { : git add ; if [ $# -eq 0 ]; then set -- $(git diff --name-only --diff-filter=U); fi; git add \"$@\"; }; cd \"$GIT_PREFIX\" && f"

	resolve = "!f() { : git add ; if [ $# -eq 0 ]; then set -- $(git diff --name-only --diff-filter=U); fi; ~/.git_wrappers/resolve.sh \"$@\"; read -n1 -p\"Resolved? [y/N]: \"; echo; if [ \"$(echo $REPLY | tr '[A-Z]' '[a-z]')\" == \"y\" ]; then git add \"$@\"; fi; }; cd \"$GIT_PREFIX\" && f"
	resolve-mine = "!f() { : git add ; if [ $# -eq 0 ]; then set -- $(git diff --name-only --diff-filter=U); fi; git checkout --ours \"$@\" && git add \"$@\"; }; cd \"$GIT_PREFIX\" && f"
	resolve-ours = !git resolve-mine
	resolve-theirs = "!f() { : git add ; if [ $# -eq 0 ]; then set -- $(git diff --name-only --diff-filter=U); fi; git checkout --theirs \"$@\" && git add \"$@\"; }; cd \"$GIT_PREFIX\" && f"
[add]
	ignoreErrors = true
[color]
	branch = auto
	diff = auto
	grep = auto
	interactive = auto
	pager = false
	status = auto
	ui = true
[column]
	ui = never
[grep]
	lineNumber = true
	patternType = extended
[push]
	default = upstream
[merge]
	conflictstyle = diff3
[core]
	pager = less -RFiMx4 -+S
	editor = ~/.git_wrappers/commit.sh
	excludesfile = /home/olihul/.gitignore
	safecrlf = true
	abbrev = 11
[log]
	date = local
[branch]
	autosetuprebase = always
[pull]
	rebase = true
[help]
	autocorrect = 5
[remote "origin"]
	fetch = refs/heads/*:refs/remotes/origin/*
	fetch = refs/tags/*:refs/tags/*
