# -*- mode: ruby -*-
# vi: set ft=ruby :

def syscall(cmd)
	system("echo " + cmd)
	system(cmd)
end

if !Vagrant.has_plugin?("vagrant-triggers") 
	syscall('vagrant plugin install vagrant-triggers')
	
	raise("vagrant-triggers installed. Run command again.")
end

VM_NAME ||= "Centos7Dev-64bit-olihul"

require_relative 'vbox_manage'

syscall('mkdir "H:\backups\etc\Windows PC" 2> nul > nul')
syscall('copy /Y /Z "C:\Users\olihul\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\launch-centos7dev-vm.bat" "H:\backups\etc\Windows PC" 2> nul > nul')
syscall('copy /Y /Z "H:\backups\.ssh" "C:\Users\olihul\.ssh" 2> nul > nul')
syscall('git pull 2> nul > nul')

# All Vagrant configuration is done below. The "2" in Vagrant.configure
# configures the configuration version (we support older styles for
# backwards compatibility). Please don't change it unless you know what
# you're doing.
Vagrant.configure("2") do |config|
	# The most common configuration options are documented and commented below.
	# For a complete reference, please see the online documentation at
	# https://docs.vagrantup.com.

	# Every Vagrant development environment requires a box. You can search for
	# boxes at https://atlas.hashicorp.com/search.
	config.vm.box = "optiver/centos7dev"
	# Lock this Vagrant environment to the box versioned as 2.3
	#config.vm.box_version = "2.99"

	# Disable automatic box update checking. If you disable this, then
	# boxes will only be checked for updates when the user runs
	# `vagrant box outdated`. This is not recommended.
	# config.vm.box_check_update = false

	# Create a forwarded port mapping which allows access to a specific port
	# within the machine from a port on the host machine. In the example below,
	# accessing "localhost:8080" will access port 80 on the guest machine.
	config.vm.network "forwarded_port", guest: 22, host: 22
	config.vm.network "forwarded_port", guest: 80, host: 80
	config.vm.network "forwarded_port", guest: 8000, host: 8000
	config.vm.network "forwarded_port", guest: 8080, host: 8080

	# Create a private network, which allows host-only access to the machine
	# using a specific IP.
	# config.vm.network "private_network", ip: "192.168.33.10"

	# Create a public network, which generally matched to bridged network.
	# Bridged networks make the machine appear as another physical device on
	# your network.
	config.vm.network "public_network"

	config.vm.provider "virtualbox" do |v|
		v.name = VM_NAME
		v.memory = "24576"
		v.cpus = 4
		v.gui = true
		v.customize ["modifyvm", :id, "--draganddrop", "bidirectional"]
	end
	
	config.vm.hostname = "3100-centos7dev"
	
	config.vm.synced_folder 'C:/Repo', '/C_REPO', mount_options: ["fmode=0644,dmode=0755"], owner: "#{ENV['USERNAME']}", group: "users"
	config.vm.synced_folder 'H:/backups', '/H_DRIVE', mount_options: ["fmode=0644,dmode=0755"], owner: "#{ENV['USERNAME']}", group: "users"
	
	controller_name = "SATA Controller"
	controller_portcount = "6"
	controller_port = "5"
	controller_device = "0"
	controller_type = "sata"
	config.vm.provider "virtualbox" do |v|
		data_disk = "D:\\VirtualDisks\\olihul-data.vmdk"
		unless File.exist?(data_disk)
			v.customize ['createmedium', 'disk', '--filename', data_disk, '--variant', 'Fixed', '--size', 300 * 1024]
		end
		## SATA Controller is created by optiver/centos7dev now (as of v2.150)
		## This magic never worked, I suspect vm_controller() is evaluated at the start, then the upstream provisioning creates the controller and we try to re-create it.
        # unless vm_controller(controller_name) != ""
        #     v.customize ["storagectl", :id, "--add", controller_type, "--name", controller_name, "--portcount", controller_portcount]
        # end
        v.customize ["storageattach", :id, "--storagectl", controller_name, "--port", controller_port, "--device", controller_device, "--type", "hdd", "--medium", data_disk]
	end
	config.trigger.before :destroy do
		case vm_running?
		when true
			syscall(["VBoxManage", "controlvm", vm_uuid, "acpipowerbutton"].join(' '))
			syscall(["VBoxManage", "controlvm", vm_uuid, "acpipowerbutton"].join(' '))
			sleep(5)
			syscall(["VBoxManage", "controlvm", vm_uuid, "poweroff"].join(' '))
		end
		vm_exists? ? syscall(["VBoxManage", "storageattach", vm_uuid, "--storagectl", '"' + controller_name + '"', "--port", controller_port, "--device", controller_device, "--type", "hdd", "--medium", "none"].join(' ')) : true
	end
	config.vm.provision "shell" do |s|
		s.inline = <<-SHELL
			if [ ! -e "/dev/disk/by-label/data" ]; then
				echo "Doing initial data disc setup..."
				dev=
				for d in /dev/sd[a-z]; do
					dev="$d"
				done
				if [ -z "$dev" ]; then
					echo "Could not determine data disc device"
				else
					echo "Creating data partition on $dev..."
					parted -s "$dev" mklabel msdos
					parted -s "$dev" mkpart primary ext4 0% 100%
					echo "Making data file-system ${dev}1..."
					mkfs -t ext4 -v -L data "${dev}1"
				fi
			fi
		SHELL
	end
	config.vm.provision "shell", run: "always" do |s|
		s.args = "#{ENV['USERNAME']}"
		s.inline = <<-SHELL
			HOME="/home/$1"
			
			echo "Mounting data drive..."
			mount --label=data ${HOME} -t ext4 -o defaults,noatime,commit=300
			chown olihul:users ${HOME}
			
			true
		SHELL
	end
	config.vm.provision "shell" do |s|
		s.args = "#{ENV['USERNAME']}"
		s.path = "setup.sh"
	end
	config.vm.provision "shell", run: "always" do |s|
		s.args = "#{ENV['USERNAME']}"
		s.inline = <<-SHELL
			HOME="/home/$1"
			
			rm -rf /tmp/.ssh 2>/dev/null
			
			echo "Running disc tweaks..."
			${HOME}/dot-files/bin/disc-tweaks.sh
			
			true
		SHELL
	end
	
	# Triggers, depends on:
	# vagrant plugin install vagrant-triggers
	config.trigger.after [:up, :resume, :reload] do
		syscall("net use F: \\\\centos_dev_vm\\#{ENV['USERNAME']}")
	end
	config.trigger.before [:halt, :suspend, :reload, :destroy] do
		syscall("net use F: /DELETE")
	end
end
