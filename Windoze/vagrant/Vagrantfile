# -*- mode: ruby -*-
# vi: set ft=ruby :

def syscall(cmd)
	system("echo " + cmd)
	system(cmd)
end

if !Vagrant.has_plugin?("vagrant-triggers") 
	syscall('vagrant plugin install vagrant-triggers')
	
	raise("vagrant-triggers installed. Run command again.")
end

VM_NAME ||= "Centos7Dev-64bit-olihul"

require_relative 'vbox_manage'

syscall('mkdir "H:\backups\etc\Windows PC"')
syscall('copy /Y /Z "C:\Users\olihul\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\launch-centos7dev-vm.bat" "H:\backups\etc\Windows PC"')

# All Vagrant configuration is done below. The "2" in Vagrant.configure
# configures the configuration version (we support older styles for
# backwards compatibility). Please don't change it unless you know what
# you're doing.
Vagrant.configure("2") do |config|
	# The most common configuration options are documented and commented below.
	# For a complete reference, please see the online documentation at
	# https://docs.vagrantup.com.

	# Every Vagrant development environment requires a box. You can search for
	# boxes at https://atlas.hashicorp.com/search.
	config.vm.box = "optiver/centos7dev"
	# Lock this Vagrant environment to the box versioned as 2.3
	#config.vm.box_version = "2.99"

	# Disable automatic box update checking. If you disable this, then
	# boxes will only be checked for updates when the user runs
	# `vagrant box outdated`. This is not recommended.
	# config.vm.box_check_update = false

	# Create a forwarded port mapping which allows access to a specific port
	# within the machine from a port on the host machine. In the example below,
	# accessing "localhost:8080" will access port 80 on the guest machine.
	config.vm.network "forwarded_port", guest: 22, host: 22
	config.vm.network "forwarded_port", guest: 80, host: 80
	config.vm.network "forwarded_port", guest: 8000, host: 8000
	config.vm.network "forwarded_port", guest: 8080, host: 8080

	# Create a private network, which allows host-only access to the machine
	# using a specific IP.
	# config.vm.network "private_network", ip: "192.168.33.10"

	# Create a public network, which generally matched to bridged network.
	# Bridged networks make the machine appear as another physical device on
	# your network.
	config.vm.network "public_network"

	config.vm.provider "virtualbox" do |v|
		v.name = VM_NAME
		v.memory = "24576"
		v.cpus = 4
		v.gui = true
		v.customize ["modifyvm", :id, "--draganddrop", "bidirectional"]
	end
	
	config.vm.hostname = "3100-centos7dev"
	
	config.vm.synced_folder 'C:/Repo', '/C_REPO', mount_options: ["fmode=0644,dmode=0755"], owner: "#{ENV['USERNAME']}", group: "users"
	config.vm.synced_folder 'H:/backups', '/H_DRIVE', mount_options: ["fmode=0644,dmode=0755"], owner: "#{ENV['USERNAME']}", group: "users"
	
	config.vm.provider "virtualbox" do |v|
        unless vm_controller("SATA Controller") != ""
            v.customize ["storagectl", :id, "--add", "sata", "--name", "SATA Controller", "--portcount", "1"]
        end
		data_disk = "D:\\VirtualDisks\\olihul-data.vmdk"
		unless File.exist?(data_disk)
			v.customize ['createmedium', 'disk', '--filename', data_disk, '--variant', 'Fixed', '--size', 300 * 1024]
		end
        v.customize ["storageattach", :id, "--storagectl", "SATA Controller", "--port", "0", "--device", "0", "--type", "hdd", "--medium", data_disk]
	end
	config.vm.provision "shell" do |s|
		s.inline = <<-SHELL
			if [ ! -e "/dev/disk/by-label/data" ]; then
				echo "Doing initial data disc setup..."
				echo "Creating data partition..."
				parted -s /dev/sda mklabel msdos
				parted -s /dev/sda mkpart primary ext4 0% 100%
				echo "Making data file-system..."
				mkfs -t ext4 -v -L data /dev/sda1
			fi
		SHELL
	end
	config.vm.provision "shell", run: "always" do |s|
		s.args = "#{ENV['USERNAME']}"
		s.inline = <<-SHELL
			HOME="/home/$1"
			
			echo "Mounting data drive..."
			mount --label=data ${HOME} -t ext4 -o defaults,noatime,commit=300
			chown olihul:users ${HOME}
			
			true
		SHELL
	end
	if File.exists?(File.join("..", "..", "parts"))
		config.vm.provision "file", source: File.join("..", "..", "parts"), destination: "/tmp/parts"
	end
	config.vm.provision "shell" do |s|
		s.args = "#{ENV['USERNAME']} /tmp/parts"
		s.path = "setup.sh"
	end
	config.vm.provision "shell", run: "always" do |s|
		s.args = "#{ENV['USERNAME']}"
		s.inline = <<-SHELL
			HOME="/home/$1"
			
			echo "Copying files provisioned into ${HOME} by base image..."
			mkdir /tmp/home/ 2>/dev/null
			mount /dev/mapper/vgdata-home.fs /tmp/home
			rsync -rAXog /tmp/${HOME}/ ${HOME}/
			umount /tmp/home/
			rmdir /tmp/home/
			
			echo "Restarting KDE to pick up restored backups..."
			init 3 # This abrubtly kills KDE
			init 5 # And this brings it back online
			
			echo "Running disc tweaks..."
			${HOME}/bin/disc-tweaks.sh
			
			true
		SHELL
	end
	
	# Triggers, depends on:
	# vagrant plugin install vagrant-triggers
	config.trigger.after [:up, :resume, :reload] do
		syscall("net use F: \\\\centos_dev_vm\\#{ENV['USERNAME']}")
	end
	config.trigger.before [:halt, :suspend, :reload, :destroy] do
		syscall("net use F: /DELETE")
	end
	config.trigger.before :destroy do
		case vm_running?
		when true
			syscall(["VBoxManage", "controlvm", vm_uuid, "acpipowerbutton"].join(' '))
			syscall(["VBoxManage", "controlvm", vm_uuid, "acpipowerbutton"].join(' '))
			sleep(5)
			syscall(["VBoxManage", "controlvm", vm_uuid, "poweroff"].join(' '))
		end
		vm_exists? ? syscall(["VBoxManage", "storageattach", vm_uuid, "--storagectl", '"SATA Controller"', "--port", "0", "--device", "0", "--type", "hdd", "--medium", "none"].join(' ')) : true
	end
end
